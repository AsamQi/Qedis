#if defined(__gnu_linux__)
    #include <unistd.h>
    #include <signal.h>
#endif

#include <cstring>
#include <cassert>
#include "Thread.h"
#include "ThreadPool.h"
#include "../Log/Logger.h"

Thread::Thread(ThreadPool* p, Runnable* runnable) :
m_pool(p),
m_runnable(runnable),
m_handle(INVALID_HANDLE_VALUE),
m_tid(0),
m_mutex(1)
{
    m_working = false;
    DBG << "creat thread but not run";
}

Thread::~Thread()
{    
    DBG << "delete thread ";
    if (m_runnable) delete m_runnable;
}


#if defined(__gnu_linux__)
void*           Thread::ThreadFunc(void* arg) 
#else
uint32_t WINAPI Thread::ThreadFunc(void* arg)
#endif
{
    Thread* pThread        = (Thread* ) arg;
    pThread->m_working    = true;
    pThread->m_tid        = Thread::GetCurrentThreadId();
    pThread->m_mutex.Post();

#if defined(__gnu_linux__)
    sigset_t mask;
    ::sigfillset(&mask);
    ::pthread_sigmask(SIG_SETMASK, &mask, NULL);
#endif

    DBG << "Start thread id " << (Thread::GetCurrentThreadId() & 0xFFFF);
    while (pThread->m_working)
    {
        pThread->_Run();
        
        delete   pThread->m_runnable;
        pThread->m_runnable = 0;
        
        if (NULL != pThread->m_pool)
        {
            pThread->Suspend();
        }
        else 
        {
            break;
        }
    }

    DBG << "Exit thread id " << (Thread::GetCurrentThreadId() & 0xFFFF);
#if defined(__gnu_linux__)
    ::pthread_exit(0);
#else
    ::_endthreadex(0);
#endif

    return 0;
}

void Thread::Sleep(unsigned int seconds)
{
#if defined(__gnu_linux__)
    ::sleep(seconds);
#else
    ::Sleep(seconds * 1000);
#endif
}

void Thread::MSleep(unsigned int mSeconds)
{
#if defined(__gnu_linux__)
    ::usleep(mSeconds * 1000U);
#else
    ::Sleep(mSeconds);
#endif
}

bool Thread::Start()
{
    m_mutex.Wait(); 
    if (!m_working)
    {
        if (!Thread::_LaunchThread(m_handle, ThreadFunc, this))
        {
            m_mutex.Post();
            return false;
        }
    }
    else
    {
        m_mutex.Post();
    }

    return true;
}

bool Thread::_LaunchThread(THREAD_HANDLE& handle, PTHREADFUNC func, void* arg)
{
#if defined(__gnu_linux__)
        return 0 == ::pthread_create(&handle, NULL, func, arg);
#else
        handle = (THREAD_HANDLE)_beginthreadex(0, 0, func, arg, 0, 0);
        return 0 != handle && INVALID_HANDLE_VALUE != handle;
#endif
}

void Thread::_Run()
{
    if (NULL != m_runnable)
    {
        m_runnable->Run();
    }
}

void Thread::StopMe()
{
    m_working = false;
    if (m_runnable)
    {
        m_runnable->Stop();
    }
}

void Thread::Join()
{
    if (INVALID_HANDLE_VALUE == m_handle)
        return;
#if defined(__gnu_linux__)
    ::pthread_join(m_handle, NULL);
#else
    ::WaitForSingleObject(m_handle, INFINITE);
    ::CloseHandle(m_handle);
#endif
    m_handle = INVALID_HANDLE_VALUE;
}

void Thread::Suspend()
{    
    assert(m_tid == Thread::GetCurrentThreadId());
    m_sem.Wait();
}

void Thread::Resume()
{    
    assert(m_tid != Thread::GetCurrentThreadId());
    ERR << "Resume tid " << (m_tid&0xffff);
    m_sem.Post();
}

THREAD_ID Thread::GetCurrentThreadId()
{
#if defined(__gnu_linux__)
    return ::pthread_self();
#else
    return ::GetCurrentThreadId();
#endif
}

void Thread::YieldCPU()
{
#if defined(__gnu_linux__)
    ::usleep(10);
#else
    if (!::SwitchToThread())
        ::Sleep(1);
#endif
}
