#ifndef BERT_THREAD_H
#define BERT_THREAD_H

#include  <string>
#include  "Atomic.h"
#include  "IPC.h"

#if defined(__gnu_linux__)
    #include <pthread.h>
    typedef pthread_t   THREAD_HANDLE;
    typedef pthread_t   THREAD_ID;
    #define INVALID_HANDLE_VALUE   (pthread_t)(-1)
#else
    #include  <WinBase.h>
    #include  <process.h>
    typedef HANDLE   THREAD_HANDLE;
    typedef DWORD    THREAD_ID;
#endif

class Runnable
{
protected:
    volatile bool  m_running;

public:
    Runnable() :  m_running(true)
    {
    }

    virtual  ~Runnable()  { }

    virtual void  Run() = 0;
    bool   IsAlive() const {  return m_running;   }
    void   Stop()          {  m_running = false;  }
};


class ThreadPool;
class Thread
{
    friend class ThreadPool;

    // Belong to this pool, if NULL, run once and exit
    ThreadPool*        m_pool;
    Runnable* volatile m_runnable;

    THREAD_HANDLE m_handle;
    THREAD_ID     m_tid;

    // Protect pthread_create
    Semaphore     m_mutex;

    // Control suspend and resume
    Semaphore     m_sem;
 
    // Has called pthread_create?
    volatile bool m_working;

#if defined(__gnu_linux__)
    typedef void * (*PTHREADFUNC)(void* ); 
    static  void * ThreadFunc(void* );
#else
    typedef uint32_t (WINAPI *PTHREADFUNC)(void* ); 
    static  uint32_t  WINAPI ThreadFunc(void* );
#endif

public:
    explicit Thread(ThreadPool* = NULL, Runnable* = NULL);
    ~Thread();

    void      SetRunnableEntity(Runnable* r)  { m_runnable = r;    }
    Runnable* GetRunnableEntity() const       { return m_runnable; }

    THREAD_ID     GetThreadID()     { return m_tid; }
    THREAD_HANDLE GetThreadHandle() { return m_handle; }
    
    static void   Sleep(unsigned int seconds);
    static void   MSleep(unsigned int mSeconds);
    
    bool   Start();
    bool   Idle() const { return NULL == m_runnable; }

private:
    void   _Run();
    static bool  _LaunchThread(THREAD_HANDLE& handle, PTHREADFUNC func, void* arg);

public:    
    void   StopMe();
    void   Join();
    
    void   Suspend();
    void   Resume();

    static THREAD_ID   GetCurrentThreadId();
    static void        YieldCPU();

private:
    Thread(const Thread& );

    Thread& operator= (const Thread& );
};

#endif
