
#include <cstdlib>
#include <cstdio>
#include <cstring>
#include <cstdarg>
#include <errno.h>

#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>

#define RED_COLOR       1
#define GREEN_COLOR     2
#define YELLOW_COLOR    3
#define NORMAL_COLOR    4
#define BLUE_COLOR      5
#define PURPLE_COLOR    6
#define WHITE_COLOR     7
#define COLOR_MAX       8

#include "Logger.h"
#include "../Timer.h"


Logger   g_logger;


#define DEFAULT_LOGFILESIZE    (8 * 1024 * 1024)
#define PREFIX_LEVEL_LEN       (6)
#define PREFIX_TIME_LEN        (20)


Logger::Logger() : m_level(0), m_dest(0), m_pMemory(0), m_offset(DEFAULT_LOGFILESIZE)
{
    _ResetPos();
    m_file = -1;
    m_fileName.reserve(32);
}

Logger::~Logger()
{
    _CloseLogFile();
}

bool Logger::Init(unsigned int level, unsigned int dest, const char* prefix, const char* pDir)
{
    m_level      = level;
    m_dest       = dest;
    m_prefix     = prefix ? prefix : "";
    m_directory  = pDir ? pDir : "defaultLog";

    if (!m_directory.empty())
    {
        if (!(m_dest & logFILE) || !_MakeDir(m_directory.c_str()))
            return false;
    }
    else if (m_dest & logConsole)
        m_dest &= ~logFILE; // NO file output
    else
        return false; // MUST HAVE CONSOLE OR FILE

    return true;
}

bool Logger::_CheckChangeFile()
{
    if (-1 == m_file)
        return true;
    
    return m_offset + MAXLINE_LOG >= DEFAULT_LOGFILESIZE;
}

const std::string& Logger::_MakeFileName()
{
    char   name[32];
    Time   now;
    now.FormatTime(name, sizeof(name) - 1);

    //m_fileName  = m_directory + "/" + name;
    m_fileName  = m_directory + "/" + m_prefix + name;
    m_fileName += ".log";

    return m_fileName;
}

bool Logger::_OpenLogFile(const char* name)
{
    if (-1 != m_file)
        return false;   // CLOSE PREVIOUS LOG FILE PLEASE!

    m_file = ::open(name, O_RDWR | O_CREAT | O_APPEND, 0644);
    if (-1 == m_file)
        return false;

    struct stat st;
    fstat(m_file, &st);
    m_offset  = st.st_size; // for append

    ::ftruncate(m_file, DEFAULT_LOGFILESIZE);
    m_pMemory = (char* )::mmap(0, DEFAULT_LOGFILESIZE, PROT_WRITE, MAP_SHARED, m_file, 0);
    return (char*)-1 != m_pMemory;
}

bool Logger::_CloseLogFile()
{
    bool bOk = true;
    if (-1 != m_file)
    {
        ::munmap(m_pMemory, DEFAULT_LOGFILESIZE);
        ::ftruncate(m_file, m_offset);
        ::close(m_file);

        m_pMemory   = 0;
        m_offset    = 0;
        m_file      = -1;
    }
    return bOk;    
}


void Logger::Flush(enum LogLevel level)
{
    if (m_pos <= PREFIX_TIME_LEN + PREFIX_LEVEL_LEN) {
        _ResetPos();
        return;
    }

    if (IsLevelForbid(level))  {
        _ResetPos();
        return;
    }

    g_now.FormatTime(m_buffer, PREFIX_TIME_LEN + 1);

    switch(level)   {    
    case logINFO:
        _Color(GREEN_COLOR);
        strncpy(m_buffer + PREFIX_TIME_LEN, "[INF]:", PREFIX_LEVEL_LEN);
        break;

    case logDEBUG:
        _Color(WHITE_COLOR);
        strncpy(m_buffer + PREFIX_TIME_LEN, "[DBG]:", PREFIX_LEVEL_LEN);
        break;

    case logWARN:
        _Color(YELLOW_COLOR);
        strncpy(m_buffer + PREFIX_TIME_LEN, "[WRN]:", PREFIX_LEVEL_LEN);
        break;

    case logERROR:
        _Color(RED_COLOR);
        strncpy(m_buffer + PREFIX_TIME_LEN, "[ERR]:", PREFIX_LEVEL_LEN);
        break;

    case logCRITICAL:
        _Color(PURPLE_COLOR);
        strncpy(m_buffer + PREFIX_TIME_LEN, "[CRI]:", PREFIX_LEVEL_LEN);
        break;

    case logUSR:
        _Color(BLUE_COLOR);
        strncpy(m_buffer + PREFIX_TIME_LEN, "[USR]:", PREFIX_LEVEL_LEN);
        break;

    default:    
        _Color(RED_COLOR);
        strncpy(m_buffer + PREFIX_TIME_LEN, "[???]:", PREFIX_LEVEL_LEN);
        break;
    }

#if !defined(__gnu_linux__)
    m_buffer[m_pos ++] = '\r';
    
#endif

    m_buffer[m_pos ++] = '\n';
    m_buffer[m_pos] = '\0';

    if (m_dest & logConsole)
        fprintf(stdout, "%s", m_buffer);

    _Color(NORMAL_COLOR);

    if (m_dest & logFILE)
    {
        while (_CheckChangeFile())
        {
            if (!_CloseLogFile() || !_OpenLogFile(_MakeFileName().c_str()))
            {   //OOPS!!! IMPOSSIBLE!
                return;
            }
        }

        ::memcpy(m_pMemory + m_offset, m_buffer, m_pos);
        m_offset += m_pos;
    }
        
    _ResetPos();
}

void Logger::_Color(unsigned int color)
{
    static const char* colorstrings[COLOR_MAX] = {
        "",
        "\033[1;31;40m",
        "\033[1;32;40m",
        "\033[1;33;40m",
        "\033[0m",
        "\033[1;34;40m",
        "\033[1;35;40m",
        "\033[1;37;40m",
    };
    fprintf(stdout, colorstrings[color]);
}

bool Logger::_MakeDir(const char* pDir)
{
    if (pDir && 0 != mkdir(pDir, 0755))
    {
        if (EEXIST != errno)
            return false;
    }
    return true;
}

Logger&  Logger::operator<< (const char* msg)
{
    if (m_pos >= MAXLINE_LOG) {
        return  *this;
    }

    const int len = strlen(msg);
    if (m_pos + len >= MAXLINE_LOG)  {
        return *this;
    }

    memcpy(m_buffer + m_pos, msg, len);
    m_pos += len;

    return  *this;
}

Logger&  Logger::operator<< (const unsigned char* msg)
{
    return operator<<(reinterpret_cast<const char*>(msg));
}

Logger&  Logger::operator<< (void* ptr)
{
    if (m_pos + 18 < MAXLINE_LOG)
    {
        unsigned long ptrValue = (unsigned long)ptr;
        int nbytes = snprintf(m_buffer + m_pos, MAXLINE_LOG - m_pos, "%#018lx", ptrValue);
        if (nbytes > 0) m_pos += nbytes;
    }

    return  *this;  
}


Logger&  Logger::operator<< (unsigned char a)
{
    if (m_pos + 3 < MAXLINE_LOG)
    {
        int  nbytes = snprintf(m_buffer + m_pos, MAXLINE_LOG - m_pos, "%hhd", a);
        if (nbytes > 0) m_pos += nbytes;
    }

    return  *this;
}


Logger&  Logger::operator<< (char a)
{
    if (m_pos + 3 < MAXLINE_LOG)
    {
        int  nbytes = snprintf(m_buffer + m_pos, MAXLINE_LOG - m_pos, "%hhu", a);
        if (nbytes > 0) m_pos += nbytes;
    }

    return  *this;
}

Logger&  Logger::operator<< (unsigned short a)
{
    if (m_pos + 5 < MAXLINE_LOG)
    {
        int  nbytes = snprintf(m_buffer + m_pos, MAXLINE_LOG - m_pos, "%hu", a);
        if (nbytes > 0) m_pos += nbytes;
    }

    return  *this;
}

Logger&  Logger::operator<< (short a)
{
    if (m_pos + 5 < MAXLINE_LOG)
    {
        int  nbytes = snprintf(m_buffer + m_pos, MAXLINE_LOG - m_pos, "%hd", a);
        if (nbytes > 0) m_pos += nbytes;
    }

    return  *this;
}

Logger&  Logger::operator<< (unsigned int a)
{
    if (m_pos + 10 < MAXLINE_LOG)
    {
        int  nbytes = snprintf(m_buffer + m_pos, MAXLINE_LOG - m_pos, "%u", a);
        if (nbytes > 0) m_pos += nbytes;
    }

    return  *this;
}

Logger&  Logger::operator<< (int a)
{
    if (m_pos + 10 < MAXLINE_LOG)
    {
        int  nbytes = snprintf(m_buffer + m_pos, MAXLINE_LOG - m_pos, "%d", a);
        if (nbytes > 0) m_pos += nbytes;
    }

    return  *this;
}

Logger&  Logger::operator<< (unsigned long a)
{
    if (m_pos + 20 < MAXLINE_LOG)
    {
        int  nbytes = snprintf(m_buffer + m_pos, MAXLINE_LOG - m_pos, "%lu", a);
        if (nbytes > 0) m_pos += nbytes;
    }

    return  *this;
}

Logger&  Logger::operator<< (long a)
{
    if (m_pos + 20 < MAXLINE_LOG)
    {
        int  nbytes = snprintf(m_buffer + m_pos, MAXLINE_LOG - m_pos, "%ld", a);
        if (nbytes > 0) m_pos += nbytes;
    }

    return  *this;
}

Logger&  Logger::operator<< (unsigned long long a)
{
    if (m_pos + 20 < MAXLINE_LOG)
    {
        int  nbytes = snprintf(m_buffer + m_pos, MAXLINE_LOG - m_pos, "%llu", a);
        if (nbytes > 0) m_pos += nbytes;
    }

    return  *this;
}

Logger&  Logger::operator<< (long long a)
{
    if (m_pos + 20 < MAXLINE_LOG)
    {
        int  nbytes = snprintf(m_buffer + m_pos, MAXLINE_LOG - m_pos, "%lld", a);
        if (nbytes > 0) m_pos += nbytes;
    }

    return  *this;
}


void   Logger::_ResetPos()
{
    m_pos  = PREFIX_LEVEL_LEN + PREFIX_TIME_LEN ;
}

