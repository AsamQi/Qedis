
#ifndef BERT_LOGGER_H
#define BERT_LOGGER_H

#include <string>

enum LogLevel
{
    logINFO     = 0x01 << 0,
    logDEBUG    = 0x01 << 1,
    logWARN     = 0x01 << 2,
    logERROR    = 0x01 << 3,
    logCRITICAL = 0x01 << 4,
    logUSR      = 0x01 << 5,
    logALL      = 0xFFFFFFFF,
};

// 和OI_LOG的级别兼容
inline unsigned int ConvertLoglevel(int level)
{
    if (level < 0)
        level = 0; // close log except USR
    else if (level > 5)
        level = 5;

    unsigned int result = logUSR;
    switch (level) {
        case 5:
            result |= logINFO;  // Fall through

        case 4:
            result |= logDEBUG; 

        case 3:
            result |= logWARN;

        case 2:
            result |= logCRITICAL;

        case 1:
            result |= logERROR;
    }

    return  result;
}


enum LogDest
{
    logConsole  = 0x01 << 0,
    logFILE     = 0x01 << 1,
};


class Logger
{
public:
    Logger();
    ~Logger();
    bool Init(unsigned int level = logDEBUG,
        unsigned int dest = logConsole,
        const char* prefix = 0,
        const char* pDir  = 0);
    void Flush(LogLevel  level);
    bool IsLevelForbid(unsigned int level)  {  return  !(level & m_level); };

    Logger&  operator<<(const char* msg);
    Logger&  operator<<(const unsigned char* msg);
    Logger&  operator<<(void* msg);
    Logger&  operator<<(unsigned char a);
    Logger&  operator<<(char a);
    Logger&  operator<<(unsigned short a);
    Logger&  operator<<(short a);
    Logger&  operator<<(unsigned int a);
    Logger&  operator<<(int a);
    Logger&  operator<<(unsigned long a);
    Logger&  operator<<(long a);
    Logger&  operator<<(unsigned long long a);
    Logger&  operator<<(long long a);

    void    _ResetPos();

private:
#define MAXLINE_LOG            (2048)
    char            m_buffer[MAXLINE_LOG];
    int             m_pos;

    unsigned int    m_level;
    std::string     m_directory;
    unsigned int    m_dest;
    std::string     m_fileName;
    std::string     m_prefix;

    char*           m_pMemory;
    unsigned int    m_offset;
    int				m_file;
    bool    _CheckChangeFile();
    const std::string& _MakeFileName();
    bool    _OpenLogFile(const char* name);
    bool    _CloseLogFile();


    void    _Color(unsigned int color);
    static bool _MakeDir(const char* pDir);
};

extern  Logger   g_logger;


class LogHelper
{
public:
    LogHelper(LogLevel level) : m_level(level) {
    }

    void operator=(Logger& log) {
        log.Flush(m_level);
    }

private:
    LogLevel    m_level;
};


#undef INF
#undef DBG
#undef WRN
#undef CRI 
#undef ERR
#undef USR

#define  INF     g_logger.IsLevelForbid(logINFO) ? (void)g_logger._ResetPos() : (LogHelper(logINFO))=g_logger
#define  DBG     g_logger.IsLevelForbid(logDEBUG) ? (void)g_logger._ResetPos() : (LogHelper(logDEBUG))=g_logger
#define  WRN     g_logger.IsLevelForbid(logWARN) ? (void)g_logger._ResetPos() : (LogHelper(logWARN))=g_logger
#define  CRI     g_logger.IsLevelForbid(logCRITICAL) ? (void)g_logger._ResetPos() : (LogHelper(logCRITICAL))=g_logger
#define  ERR     g_logger.IsLevelForbid(logERROR) ? (void)g_logger._ResetPos() : (LogHelper(logERROR))=g_logger << __FILE__ << ", line " << __LINE__ << " : "
#define  USR     g_logger.IsLevelForbid(logUSR) ? (void)g_logger._ResetPos() : (LogHelper(logUSR))=g_logger


#endif

